/**
1)Даны неотрицательные целые числа n, k и массив целых чисел из диапазона [0..109] размера n.
Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k ∈[0..n-1] в отсортированном массиве.
Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n).
Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.
Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент.
Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j. Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
3_4. Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.
2)59094549
3)https://contest.yandex.ru/contest/30914/problems/3/
**/

#include <iostream>

#include <experimental/random>

using std::swap;
using std::cin;
using std::cout;

int Partition(int *a, int left, int right) {
    int pivot = std::experimental::randint(left, right);
    swap(a[left], a[pivot]);
    int j = right;
    for (int i = right; i >= left; i--) {
        if (a[i] > a[left]) {
            swap(a[i], a[j]);
            j--;
        }
    }
    swap(a[j], a[left]);
    return j;
}

int kStat(int *a, int n, int k) {
    int left = 0;
    int right = n - 1;
    int pivot = Partition(a, left, right);
    while (pivot != k) {
        if (k < pivot)
            right = pivot - 1;
        else
            left = pivot + 1;
        pivot = Partition(a, left, right);
    }
    return a[k];
}

int main() {
    std::ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int n, k;
    cin >> n >> k;
    int * a = new int[n];
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    cout << kStat(a, n, k);
    delete[] a;
    return 0;
}
