/**
1)ВНИМАНИЕ! Для решения данной задачи нужно использовать структуру данных стек!
Пара слов называется стековой анаграмой, если одно слово можно получить из другого,
проведя последовательность стековых операций с его буквами
(взять очередную букву исходного слова и поместить ее в стек;
взять букву из стека и добавить ее в конец выходного слова).
Для заданной пары слов требуется определить, можно ли выполнить
последовательность стековых операций, переводящую первое слово во второе.
Все буквы в слове различные. Длина анаграммы ≤ 10000.

Формат ввода
Пара слов, являющихся анаграммой.

Формат вывода
YES, если последовательность стековых операций существует и NO в противном случае.

2)54487372

3)https://contest.yandex.ru/contest/29212/problems/5_2/

**/

#include <iostream>

#include <string>

#include <stack>

int main() {
    std::string stroka1, stroka2;
    std::cin >> stroka1 >> stroka2;
    std::stack<char> Stack_of_letters;
    unsigned long long size = stroka1.size();
    int index_stroki2 = 0;
    for (int index = 0; index < size; ++index) {    // Обходим по индексам строки stroka1
        Stack_of_letters.push(stroka1[index]);  // Добавляем в Стек букв одну букву из строки stroka1
        if (Stack_of_letters.top() == stroka2[index_stroki2]) {     // Если верхушка Стека равна букве второй строки, то заходим в цикл while
            while (!Stack_of_letters.empty()) {     // и проверяем пока стек не пуст, совпадает ли вершина стека с буквой второй строки
                if (Stack_of_letters.top() == stroka2[index_stroki2]) { // Если это так, то убираем этот элемент из стека, увеличиваем индекс строки2 на 1 и проверяем следующие буквы в стеке
                    Stack_of_letters.pop();
                    index_stroki2++;
                } else {            // Если верхушка стека не равна букве второй строки, то прерываем цикл
                    break;
                }
            }
        }
        if (index_stroki2 == size && Stack_of_letters.empty()) {    // Проверяем, если индекс 2-й строки равен длине строк и Стек букв пуст, то значит все буквы совпали и мы очистили наш стек
            std::cout << "YES";                                     // Ответ YES в таком случае
            return 0;
        }
    }
    // В случае если мы вышли из основного цикла for, где мы каждый раз вставляем в стек новую буквы изначальной строки, это значит, что мы не может составить такую анаграмму
    std::cout << "NO";
    return 0;
}
